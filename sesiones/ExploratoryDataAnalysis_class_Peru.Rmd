<br> 
<center><img src="http://i.imgur.com/tveTlt8.png" width="300"></center>

## Course: Estadística Para el Análisis Político II<br> Semestre 2017-II<br> 
### Prof. José Manuel Magallanes, PhD 
____
## **Exploración de Datos en R**
____

<a id='beginning'></a>

La exploración de datos tiene en cuenta:

* El tipo de escala en que estén los datos (dicotómica, politómica, etc.); y las combinaciones entre estas.
* La detección del comportamiento de los datos y su afinidad (o no) con algun modelo teórico.

Los contenidos ara esta sesión se organizan asi:

1. __AED Univariado__

* Categoricos

    * [Dicotomicos](#Dichotomous)
    * Politomicos
        * [No-Ordinal](#Nordinal)
        * [Ordinal](#Ordinal)

* Numéricos
    * [Conteos](#Counts)
    * [Mediciones](#Measurements) (ratio o intervalo)
    
2. __AED Bivariado__

* [Categorical - Categorical](#catcat) 
* [Categorical - Numerical](#catnum) 
* [Numerical - Numerical](#numnum) 

<a id='Dichotomous'></a> 

## <span style="color:blue"> Exploración de variables dicotómicas</span>

Carguemos la data:
```{r, eval=TRUE}
library(RCurl)
link='https://docs.google.com/spreadsheets/d/1bDMM5s3PDC5awrSkILFRPJMlQ0j95TtVxErvvNNOHPU/pub?gid=914658997&single=true&output=csv'
myCsv <- getURL(link)
namesOfCols=c('timeStamp','nombre','apellido','tipoCole','distritoNace','regionNace','edad','sexo', 'religion')
# parsing as csv
myData=read.csv(textConnection(myCsv),col.names=namesOfCols)
```

Aqui vemos como se comporta una dicotómica:

```{r, eval=TRUE}
table(myData$sexo)
```
De manera gráfica:

```{r, eval=TRUE}
toPlot=table(myData$sexo)
barplot(toPlot,col='lightblue',
        xlab='Sexo',
        ylab='Conteo de alumnos',
        main='Distribución de sexo en el aula')
```

Para verlo como porcentajes tenemos:

```{r, eval=TRUE}
prop.table(table(myData$sexo)) # como plotearias estos resultados?
```

Es util saber si la diferencia es significativa usando la prueba $\chi^2$ :
```{r, eval=TRUE}
distribution=table(myData$sexo)
chisq.test(distribution)
```
Un valor significativo del p-value (menor a 0.05) sugiere que hay diferencias (se rechaza que haya comportamiento uniforme).

En esta situación, podemos considerar que la moda es relevante:
```{r, eval=TRUE}
names(distribution[which.max(distribution)]) #asi se obtiene
```

[Inicio](#beginning)

______
<a id='Nordinal'></a>

## <span style="color:blue"> Exploración de variables categoricas No Ordinales</span>

Exploremos la Región de procedencia:

```{r, eval=TRUE}
table(myData$regionNace)
```
Hay dos Limas?

```{r,eval=TRUE}
# asumo que alguien escribió "Lima " (con algun espacio en blanco)
# así que mejor leo eliminando (stripping) los espacios en cada celda...
myData=read.csv(textConnection(myCsv),col.names=namesOfCols,stringsAsFactors =FALSE,strip.white = TRUE) 
# por que 'stringsAsFactors =FALSE'??
table(myData$regionNace)
```

Simbolos raros por el lenguaje español!...veamos:
```{r, eval=TRUE}
names(table(myData$regionNace))
```

Buscando la ubicación, cambiamos a lo que deseamos:
```{r, eval=TRUE}
# esto es un problema de 'encoding'
ancashBad=names(table(myData$regionNace))[1]
juninBad=names(table(myData$regionNace))[5]

myData$regionNace[myData$regionNace==ancashBad]='Ancash'
myData$regionNace[myData$regionNace==juninBad] ='Junin'
table(myData$regionNace)
```


Grafiquemos nuestra variable:

```{r, eval=TRUE}
toPlot=table(myData$regionNace)
barplot(toPlot,col='magenta',
        xlab='Region',
        ylab='Conteo de alumnos',
        main='Distribución de region de nacimiento en el aula',
        las=2)
```

Veamos la relevancia de la moda:

```{r, eval=TRUE}
distribution=table(myData$regionNace)
chisq.test(distribution)
```
El resultado sugiere que la moda es significativa; sin embargo, la técnica reporta que podría haber problemas en el resultado. Intentemos usar una simulación en la prueba:
```{r, eval=TRUE}
distribution=table(myData$regionNace)
chisq.test(distribution, simulate.p.value = T)
```


Lo anterior corrobora que hay una moda sobresaliente, la cual es:

```{r, eval=TRUE}
names(distribution[which.max(distribution)])
```

Pero si fuera el caso de religion:

```{r, eval=TRUE}
toPlot=table(myData$religion)
barplot(toPlot,col='magenta',
        xlab='Region',
        ylab='Conteo de alumnos',
        main='Distribución de region de nacimiento en el aula')
```

Dada la distribución de los valores no modales, es posible que el peso de la moda sea menor:

```{r, eval=TRUE}
distribution=table(myData$religion)
chisq.test(distribution)
```

Como sospechamos, la prueba no descarta que haya uniformidad.

Otra manera de ver la representatividad o dispersión de la moda es mediante el uso del [Gini Index](https://en.wikipedia.org/wiki/Gini_coefficient):
```{r, eval=TRUE}
library(DescTools)  # instalar antes!
myData$religion=factor(myData$religion)  # valores texto a categorico
Gini(as.numeric(myData$religion),na.rm = TRUE) # categorico a numerico
```



<br> 
<center><img src="http://i.imgur.com/sSaOozN.png" width="500"></center>

# Data Exploration in R
## Bivariate Case

## Course: Computational Thinking for Governance Analytics<br> Winter 2017<br> 

### Prof. José Manuel Magallanes, PhD 
<a id='beginning'></a>

Bivariate exploration needs to follow the following order:

1. [Categorical - Categorical](#part1) 
2. [Categorical - Numerical](#part2) 
3. [Numerical - Numerical](#part3) 


____


<a id='part1'></a>

## Categorical - Categorical

For this section, let's work with data about [Contributions to Candidates and Political Committees](https://dev.socrata.com/foundry/data.wa.gov/74eq-kst5) from the Washington State Open data portal:


```{r}
governor=read.csv('data/governor.csv',stringsAsFactors = F)
```

A quick look to the types we have:

```{r}
str(governor)
```

Let's check the distribution of _party_:
```{r}
table(governor$party)
```

... and _election year_:
```{r}
table(governor$election_year)
```

The basic way to analyze cat-cat relationships (association) is the **contingency table** (crosstab):
```{r}
table(governor$party,governor$election_year)
```

R has a particular package with many option for this kind of exploration:

```{r}
library(gmodels)
CrossTable(governor$party,governor$election_year,prop.t=F, prop.r=F, prop.c=F,prop.chisq=F)
```
We could focus just in the contributions to Reps or Dems:

```{r}
byeCategories=c('INDEPENDENT','NONE')
governorDR=governor[!governor$party%in% byeCategories,]
```

Let's try again, now showing percents:
```{r}
CrossTable(governorDR$party,governorDR$election_year,prop.t=T, prop.r=F, prop.c=F,prop.chisq=F)
```
We can see the same results, but using relative values:
```{r}
# Share along years per party:
CrossTable(governorDR$party,governorDR$election_year,prop.t=F, prop.r=T, prop.c=F,prop.chisq=F)
```

```{r}
# Share along parties per year:
CrossTable(governorDR$party,governorDR$election_year,prop.t=F, prop.r=F, prop.c=T,prop.chisq=F)
```


We can also use ${\chi}^2$ to test if the cells values represent some association between the variables:

```{r}
CrossTable(governorDR$party,governorDR$election_year,prop.t=F, prop.r=F, prop.c=F,prop.chisq=F,chisq=T)
```
This is simple visual representation:

```{r}
legendPlot=levels(as.factor(unique(governorDR$party)))
bartable = table(governorDR$party,governorDR$election_year)  ## get the cross tab
barplot(bartable, beside = TRUE,legend=legendPlot)  ## plot

```

For sure, you can represent the cross table in a nicer way:
```{r}
library(ggplot2)                           

#turn table into a data frame:
governorDRTb=as.data.frame(table(governorDR$party,governorDR$election_year))
names(governorDRTb)=c('party','election_year','f')



#Plot the Data
g <- ggplot(governorDRTb, aes(party, election_year)) + geom_point(aes(size = f), colour = "green") + theme_bw() + xlab("") + ylab("") +theme(legend.position="none")
g + scale_size_continuous(range=c(5,30)) + geom_text(aes(label = f))
```

____

<a id='part2'></a>

## Categorical - Numerical

We need to vary a little our strategy. We 'll see here that the cell represents a function applied to numeric values:

```{r}
with(governorDR, tapply(amount, list(code=code,party=party), mean) )
```

Above, each cell is the mean by a contributors to a party.

We could use again boxplots to see differences in the distribution of a numerical variable:
```{r}
business = governorDR[governorDR$code=='Business',]
p <- ggplot(business, aes(party, amount))

p + geom_boxplot()

```


I want to build confidence intervals of these variables:
```{r}
# Function for the standard error (se):
seMean = function(x) sd(x)/sqrt(length(x))

# Means by group
means=aggregate(list(mean=business$amount),
          list(party=business$party),mean)

# se by group: (I am using my fucntion here)
sems=aggregate(list(seMean=business$amount),
          list(party=business$party),seMean)

# a new data frame:
data=merge(means,sems) # party is the assumed 'key'

# adding confidence interval limits:
data$lower=data$mean-2*data$seMean
data$upper=data$mean+2*data$seMean

## HERE IT IS:
data

```

We can use the above information to make a plot:
```{r}
# this creates a plot of  the points (means):
meanPlot = ggplot(data, aes(y=mean, x=party)) + geom_point()

# this adds the error bars:
errorPlot = meanPlot + geom_errorbar(aes(ymin = lower, ymax = upper))

# final result
errorPlot
```


The previous information suggests there is too much intersection between the intervals, so a t-test should be non-significant:


```{r}
t.test(business$amount~business$party,var.equal = T)
```
The t-test suggests the means are not different. Can we conclude that both groups behave similarly? 

Let me plot the distribition of both groups:
```{r}
ggplot(business, aes(amount, colour = party)) +
  geom_density() 
```

Let's try a non-parametric test to ask if both distributions are similar:
```{r}
wilcox.test(amount ~ party, data=business)
```
The non-parametric case found that both distributions are different. 

Let's see a more complicated case (more than two categories):
```{r}
m <- ggplot(governorDR, aes(x = amount))
m + geom_histogram(bins=20) + facet_wrap(~code,scales = "free")
```


In this case, we can use the ANOVA (for one factor), and see if the polytomous variable creates different means:
```{r}
model = aov(amount ~ code, data = governorDR)
summary(model)

```
It detects _code_ produces differences, let's see where they are using Tukey test for post hoc comparisons:
```{r}
TukeyHSD(model)
```

The result is too long, this is a simplified version:
```{r, size=9}
result=as.data.frame(TukeyHSD(model)$code)
result[4]<0.05
```

A non-parametric alternative is the Kruskal-Wallis test.

This code will give you an error, because I did not formatted _code_ as a category (factor):
```{r, eval=FALSE}
kruskal.test(amount ~ code, data = governorDR)
```

This works:

```{r}
kruskal.test(amount ~ as.factor(code), data = governorDR)
```
The result confirms the previous finding using the F distribution. Let's use a post-hoc to see if the pairwise differences are the same:
```{r}
library(dunn.test)
result=dunn.test(governorDR$amount,as.factor(governorDR$code),  method="bh",kw=F)  
```

Again, this is an easier way to see the last result:

```{r}
data.frame(comparisons=result$comparisons,pval=result$P.adjusted<0.05)
```

We could try a more computational approach (**bootstrapping**):
```{r, message=FALSE}
library(rms)
library(dplyr)
governorDR %>%
  group_by(code) %>%
  do(data.frame(rbind(smean.cl.boot(.$amount,B=1000))))
```

____

<a id='part3'></a>

## Numerical - Numerical

Data from [Medicare Beneficiary Enrollment and Demographics](https://dev.socrata.com/foundry/data.wa.gov/2cup-2fnu)
```{r}
library(jsonlite) 
apiResponse="https://data.wa.gov/resource/2cup-2fnu.json?year=2014"
medicare = fromJSON(apiResponse)
head(medicare)
```
There are data that includes **totals** (first row above), you want to get rid of those:

```{r}
medicare2014=medicare[-1,]
```

```{r}
#resetting index after deletion
row.names(medicare2014)=NULL
```

```{r}
# what we have
str(medicare2014)
```

I want to analyse the 'percents' in these data set, but some formatting is needed:
```{r}
#positions
names(medicare2014)
```

```{r}
#to numeric
medicare2014[,c(8:14)]=lapply(medicare2014[,c(8:14)],as.numeric)
```
We can start num-num analysis now, also known and **correlation**:
```{r}
res <- cor(medicare2014[,c(8:14)],use='complete.obs')
round(res, 2)
```
Notice that the exact correlation between male and female may be discarded.

A visual representation of the correlation:
```{r}
library(car)
scatterplotMatrix(medicare2014[,c(8:14)], 
   main="Simple Scatterplot Matrix")
```


For sure, the non-parametric version can be computed:
```{r}
cor(medicare2014[,c(8:14)],use='complete.obs',method='spearman')
```



[Inicio](#beginning)

______


<a id='Ordinal'></a>

## <span style="color:blue"> Exploración de variables categoricas Ordinales</span>

Abramos nuestro archivo del _American National Election Studies Survey_ (ANES):
```{r, eval=TRUE}
library(haven)
varsOfInterest=c("libcpre_self","libcpo_self")
folder="data"
fileName="anes_timeseries_2012.sav"
fileToRead=file.path(folder,fileName)
dataSpss=read_sav(fileToRead)
dataSpssSub=as.data.frame(dataSpss)[varsOfInterest]
```

```{r,eval=TRUE}
barplot(table(dataSpssSub$libcpre_self),las=2)
```


```{r, eval=TRUE}
attr(dataSpssSub$libcpre_self,'labels')
```

```{r, eval=TRUE}
var=dataSpssSub$libcpre_self
dataSpssSub$libcpre_self=ifelse(var<0,NA,var)
```


```{r,eval=TRUE}
theTable=table(dataSpssSub$libcpre_self)
barplot(theTable,ylim = c(0, 2000))
```

Hay que transformar esta variable en ordinal:

```{r, eval=T}
dataSpssSub$libcpre_self=ordered(dataSpssSub$libcpre_self)
head(dataSpssSub$libcpre_self)
```

Mas detalle:
```{r, eval=T}
# Formatting:
theLabels=c('XLiberal','Liberal','algo_liberal','moderado',
            'algo_conservador','Conservador','XConservador')
dataSpssSub$libcpre_self=factor(dataSpssSub$libcpre_self,
                                levels = c(1:7),
                                labels=theLabels,
                                ordered=T)
levels(dataSpssSub$libcpre_self)
```

```{r, eval=TRUE}
library(DescTools) #install first! 
Median(dataSpssSub$libcpre_self,na.rm = T)
```
```{r, eval=TRUE}
# confirm:
cumsum(prop.table(table(dataSpssSub$libcpre_self)))
```


```{r, eval=TRUE}

Gini(dataSpssSub$libcpre_self,na.rm = T)
```

```{r, eval=TRUE}
Mode(dataSpssSub$libcpre_self,na.rm = T)
```

Ambos estadísticos coinciden, confirmando la simetria que se notaba en el gráfico de barras.

```{r, eval=TRUE}
boxplot(dataSpssSub$libcpre_self)
```
```{r, eval=TRUE}
library(ggplot2)
data=na.omit(dataSpssSub)
varToPlot=as.numeric(data$libcpre_self)
thePlot=ggplot(data, aes(x=1,y=varToPlot)) + geom_boxplot() 
thePlot
```
```{r, eval=TRUE}
thePlot = thePlot + coord_flip()
thePlot
```
```{r, eval=TRUE}
thePlot= thePlot + scale_y_continuous(labels= theLabels,breaks=1:7) 
thePlot
```
```{r, eval=TRUE}
thePlot + labs(title="Title", y = 'Respuestas', x=NULL) + scale_x_continuous(labels= NULL, breaks = NULL)
```



[Inicio](#beginning)

----

<a id='Counts'></a>


## <span style="color:red"> Explorando conteos</span>




```{r, eval=TRUE}
myData$edad
```


```{r, eval=TRUE}
library(stringr)

# preparar regular expression
regexp <- "[[:digit:]]+"

# procesando string
myData$edad=str_extract(myData$edad, regexp)
myData$edad=as.numeric(myData$edad)
myData$edad
```

```{r, eval=TRUE}
ggplot(myData, aes(edad)) + geom_bar()
```
```{r, eval=TRUE}
summary(myData$edad)
```

```{r, eval=TRUE}
ggplot(myData, aes(x = 1, y = edad)) + geom_boxplot() +coord_flip()
```

[Inicio](#beginning)

______

<a id='Measurements'></a>


## <span style="color:red"> Explorando mediciones</span>

```{r, eval=TRUE}
library(XML)
library(RCurl)


# URL
wiki="https://en.wikipedia.org/wiki/" 
link = "List_of_countries_by_GDP_(PPP)_per_capita" 

# Data
wikiLinkContents = getURL(paste0(wiki,link)) 
wikiTables = readHTMLTable(wikiLinkContents,
                           stringsAsFactors=FALSE)
```

```{r, eval=TRUE}
#list:
is.list(wikiTables)
# how many?
length(wikiTables)
```

Al visitar la web, nos damos cuenta la tabla de interés es la segunda:
```{r, eval=TRUE}
idx=wikiTables[[2]]
head(idx)
```


```{r, eval=TRUE}
names(idx)=c('rank','country','gdp')
idx$gdp=as.numeric(idx$gdp)
idx$gdp

```
```{r, eval=TRUE}
idx=wikiTables[[2]]
names(idx)=c('rank','country','gdp')
idx$gdp=as.numeric(gsub(",", "", idx$gdp))
idx$gdp
```

```{r, eval=TRUE}
ggplot(idx,aes(x=gdp)) + geom_histogram()
```


```{r, eval=TRUE}
ggplot(idx,aes(y=gdp,x=1)) + geom_boxplot() + coord_flip()
```
_____
<br></br>

####[VOLVER AL SILABO](https://politicaygobiernopucp.github.io/EstadisticaPoliticaGobiernoII/)